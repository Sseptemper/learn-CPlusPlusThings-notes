# 引用与指针
### 总论
1. 引用必须初始化，指针可以不初始化

2. 引用不能为空，指针可以为空

3. 引用不能更换目标，指针可以更换目标

### 引用
1. 左值引用，常规使用，表示对象的身份， `A & a`;

2. 右值引用，移动语义，避免拷贝，将临时对象(右值)直接销毁

```c++
std::vector<std::string> vec;
std::string str = "A very long string...";

vec.push_back(str);           // 传入左值，进行拷贝

// 传入右值，进行移动！str 自身被置空。
vec.push_back(std::move(str)); 
```

完美转发，根据参数其原始的值类别(左值或右值)原封不动地转发给另一个函数。

```c++
// 版本二：完美转发
template<typename T, typename Arg>
T make(Arg&& arg) { // 注意：这里是 Arg&&，通用引用
    return T(std::forward<Arg>(arg)); // 使用 std::forward 有条件地转换
}
```
>解释：

>Arg&& 是一个通用引用（当 Arg 是模板参数时）。它可以绑定到左值，也可以绑定到右值。

>`std::forward<Arg>(arg)` 是一个“有条件”的转换：

>如果原始参数 arg 是一个右值，那么 std::forward 会将其转换为右值引用（相当于 std::move），从而可以匹配到 T 的移动构造函数。

>如果原始参数 arg 是一个左值，那么 std::forward 会保持其左值属性，从而匹配到 T 的拷贝构造函数。

### 总结

>C++中引入了引用操作，在对引用的使用加了更多限制条件的情况下，保证了引用使用的安全性和便捷性，还可以保持代码的优雅性。在适合的情况使用适合的操作，引用的使用可以一定程度避免“指针满天飞”的情况，对于提升程序稳定性也有一定的积极意义。最后，指针与引用底层实现都是一样的，不用担心两者的性能差距。